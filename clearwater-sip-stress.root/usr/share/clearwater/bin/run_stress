#!/usr/bin/python
# Project Clearwater - IMS in the Cloud
# Copyright (C) 2016 Metaswitch Networks Ltd
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version, along with the "Special Exception" for use of
# the program along with SSL, set forth below. This program is distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details. You should have received a copy of the GNU General Public
# License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#
# The author can be reached by email at clearwater@metaswitch.com or by
# post at Metaswitch Networks Ltd, 100 Church St, Enfield EN2 6BQ, UK
#
# Special Exception
# Metaswitch Networks Ltd  grants you permission to copy, modify,
# propagate, and distribute a work formed by combining OpenSSL with The
# Software, or a work derivative of such a combination, even if such
# copying, modification, propagation, or distribution would otherwise
# violate the terms of the GPL. You must comply with the GPL in all
# respects for all of the code used other than OpenSSL.
# "OpenSSL" means OpenSSL toolkit software distributed by the OpenSSL
# Project and licensed under the OpenSSL Licenses, or a work based on such
# software and licensed under the OpenSSL Licenses.
# "OpenSSL Licenses" means the OpenSSL License and Original SSLeay License
# under which the OpenSSL Project distributes the OpenSSL toolkit software,
# as those licenses appear in the file LICENSE-OPENSSL.

from random import shuffle
from subprocess import Popen
from csv import DictReader, Dialect
from datetime import datetime
import csv
import argparse
from sys import exit

# Set up a CSV Dialect subclass to handle the semicolon-separated stats files
# SIPp produces
class SIPpstats(csv.excel):
	def __init__(self):
		Dialect.__init__(self)
		self.quoting = csv.QUOTE_MINIMAL
		self.delimiter = ";"

# Constants - directories and load profile

SIPP_BIN = "/usr/share/clearwater/bin/sipp"
SCRIPTS_DIR = "/usr/share/clearwater/sip-stress/"

REGISTER_CSV = "/tmp/registers.csv"
INVITE_CSV = "/tmp/calls.csv"

INITIAL_REG_ERRORS = "/var/log/clearwater-sip-stress/initialreg_errors.log"
RE_REG_ERRORS = "/var/log/clearwater-sip-stress/rereg_errors.log"
CALLER_ERRORS = "/var/log/clearwater-sip-stress/caller_errors.log"
CALLEE_ERRORS = "/var/log/clearwater-sip-stress/callee_errors.log"
RE_REG_STATS = "/var/log/clearwater-sip-stress/rereg_stats.log"
CALLER_STATS = "/var/log/clearwater-sip-stress/caller_stats.log"

BHCA = 1.3
REREG_PER_HOUR = 2.0

# Get command-line arguments

parser = argparse.ArgumentParser(description='Run stress.')
parser.add_argument('domain', help="Deployment's home domain")
parser.add_argument('subscriber_count', help='Number of subscribers to emulate', type=int)
parser.add_argument('duration', help='Number of minutes to run stress for', type=int)
parser.add_argument('--multiplier', help='Multiplier for the VoLTE load profile (e.g. passing 2 here will mean 2.6 calls and 4 re-registers per sub per hour)', type=int, default=1)
parser.add_argument('--initial-reg-rate', help='Rate to send in initial, pre-test-run registrations', type=int, default=80)
parser.add_argument('--target', help='Domain/IP and port to target stress at. Default is sprout.{domain}:5054')
parser.add_argument('--call-length', help='Call length in seconds', type=int, default=5)
parser.add_argument('--sipp-output', help='Show SIPp output screen', action='store_const', const=True, default=False)

args = parser.parse_args()

if args.target is None:
    args.target = "sprout.{}".format(args.domain)

icscf_target = args.target + ":5052"
scscf_target = args.target + ":5054"

# Calculate calls/registers per second based on the input
RPS = REREG_PER_HOUR * args.subscriber_count * args.multiplier / 3600
CPS = BHCA * args.subscriber_count * args.multiplier / 3600

# Given the duration, how many registers/calls do we need to make?
REG_MAX = int(args.duration * 60 * RPS)
CALL_MAX = int(args.duration * 60 * CPS)

SUB_START = 2010000000
SUB_END = SUB_START + args.subscriber_count

registers = range(SUB_START, SUB_END)
callers = range(SUB_START, SUB_END, 2)
callees = range(SUB_START + 1, SUB_END, 2)

# Randomly shuffle the order of registers and calls to reduce the risk of any cache issues
shuffle(registers)
shuffle(callers)
shuffle(callees)

# Generate the CSV input files - one for REGISTER messages with one user per
# line, one for INVITE flows with a caller/callee pair on each line
with open(REGISTER_CSV, "w") as f:
    f.write("SEQUENTIAL\n")
    for s in registers:
        f.write("{}\n".format(s))

with open(INVITE_CSV, "w") as f:
    f.write("SEQUENTIAL\n")
    for caller, callee in zip(callers, callees):
        f.write("{};{}\n".format(caller, callee))

null = open("/dev/null", "w+")

common_args = ["-key", "home_domain", args.domain,
               "-t", "t1"]

initial_reg_cmd = [SIPP_BIN,
                   "-sf", SCRIPTS_DIR + "register.xml",
                   "-inf", REGISTER_CSV,
                   "-trace_err", "-error_file", INITIAL_REG_ERRORS,
                   "-r", str(args.initial_reg_rate),
                   "-m", str(args.subscriber_count)] + common_args + [icscf_target]

rereg_cmd = [SIPP_BIN,
             "-sf", SCRIPTS_DIR + "register.xml",
             "-inf", REGISTER_CSV,
	     "-trace_err", "-error_file", RE_REG_ERRORS,
             "-trace_stat", "-stf", RE_REG_STATS,
             "-r", str(RPS),
             "-m", str(REG_MAX)] + common_args + [icscf_target]

caller_cmd = [SIPP_BIN,
              "-sf", SCRIPTS_DIR + "caller.xml",
              "-inf", INVITE_CSV,
              "-trace_err", "-error_file", CALLER_ERRORS,
              "-trace_stat", "-stf", CALLER_STATS,
              "-r", str(CPS),
              "-d", str(args.call_length * 1000),
              "-m", str(CALL_MAX)] + common_args + [scscf_target]

# Callee must listen on port 5082, because this is what's in the Path header in
# register.xml.

callee_cmd = [SIPP_BIN,
              "-sf", SCRIPTS_DIR + "callee.xml",
	      "-trace_err", "-error_file", CALLEE_ERRORS,
              "-p", "5082",
              "-t", "t1",
              "-m", str(CALL_MAX)]

# Do initial registrations as quickly as possible for test setup - this is an
# unrealistic load profile, so no need for measurements yet.

print "Starting initial registration, will take {} seconds".format(args.subscriber_count/args.initial_reg_rate)

if args.sipp_output:
    proc = Popen(initial_reg_cmd)
else:
    proc = Popen(initial_reg_cmd, stdout=null, stderr=null)

proc.wait()

if proc.returncode != 0:
    print "Initial registration failed - exiting"
    print "See {} for details of the errors".format(INITIAL_REG_ERRORS)
    exit(proc.returncode)
else:
    print "Initial registration succeeded"

# The test starts now
print "Starting test"
start_time = datetime.now()

# Redirect output from the re-register script and the callee script to
# /dev/null, but show the output of the caller script to allow the user to
# monitor progress.
rereg_proc = Popen(rereg_cmd, stdout=null, stderr=null)
callee_proc = Popen(callee_cmd, stdout=null, stderr=null)
if args.sipp_output:
    caller_proc = Popen(caller_cmd)
else:
    caller_proc = Popen(caller_cmd, stdout=null, stderr=null)

# Wait for the appropriate number of calls and re-registrations to have been
# attempted (and either failed or completed)
caller_proc.wait()
rereg_proc.wait()

# Kill the callee SIPp process - it might not naturally terminate (for example,
# if not all the attempted calls get through to it, so it never hits its call
# limit), and we know it's not doing anything now that caller_proc has
# completed.
callee_proc.kill()

print "Test complete"
end_time = datetime.now()

with open(CALLER_STATS) as f:
	r = DictReader(f, dialect=SIPpstats())
	for row in r:
		pass
	hours, mins, secs, nanoseconds = map(int, row['ResponseTime1(C)'].split(":"))
	rtt = (nanoseconds / 1000.0) + (secs * 1000.0)
	print """
Elapsed time: {}
Start: {}
End: {}

Total calls: {}
Successful calls: {} ({}%)
Failed calls: {} ({}%)

Retransmissions: {}

Average time from INVITE to 180 Ringing: {} ms
# of calls with 0-2ms from INVITE to 180 Ringing: {} ({}%)
# of calls with 2-20ms from INVITE to 180 Ringing: {} ({}%)
# of calls with 20-200ms from INVITE to 180 Ringing: {} ({}%)
# of calls with 200-2000ms from INVITE to 180 Ringing: {} ({}%)
# of calls with 2000+ms from INVITE to 180 Ringing: {} ({}%)""".format(
	row['ElapsedTime(C)'],
        start_time,
        end_time,
	row['TotalCallCreated'],
	row['SuccessfulCall(C)'],
	100* float(row['SuccessfulCall(C)']) / float(row['TotalCallCreated']),
	row['FailedCall(C)'],
	100* float(row['FailedCall(C)']) / float(row['TotalCallCreated']),
	row['Retransmissions(C)'],
	rtt,
	row['ResponseTimeRepartition1_<2'],
	100* float(row['ResponseTimeRepartition1_<2']) / float(row['TotalCallCreated']),
	row['ResponseTimeRepartition1_<20'],
	100* float(row['ResponseTimeRepartition1_<20']) / float(row['TotalCallCreated']),
	row['ResponseTimeRepartition1_<200'],
	100* float(row['ResponseTimeRepartition1_<200']) / float(row['TotalCallCreated']),
	row['ResponseTimeRepartition1_<2000'],
	100* float(row['ResponseTimeRepartition1_<2000']) / float(row['TotalCallCreated']),
	row['ResponseTimeRepartition1_>=2000'],
	100* float(row['ResponseTimeRepartition1_>=2000']) / float(row['TotalCallCreated']))

with open(RE_REG_STATS) as f:
	r = DictReader(f, dialect=SIPpstats())
	for row in r:
		pass
	hours, mins, secs, nanoseconds = map(int, row['ResponseTime1(C)'].split(":"))
	rtt = (nanoseconds / 1000.0) + (secs * 1000.0)
        print """
Total re-REGISTERs: {}
Successful re-REGISTERs: {} ({}%)
Failed re-REGISTERS: {} ({}%)

REGISTER retransmissions: {}

Average time from REGISTER to 200 OK: {} ms""".format(
        row['TotalCallCreated'],
        row['SuccessfulCall(C)'],
        100* float(row['SuccessfulCall(C)']) / float(row['TotalCallCreated']),
        row['FailedCall(C)'],
        100* float(row['FailedCall(C)']) / float(row['TotalCallCreated']),
        row['Retransmissions(C)'],
        rtt)

print "\nLog files in /var/log/clearwater-sip-stress"
